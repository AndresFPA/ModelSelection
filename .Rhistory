fit.SM <- sem(HS.SM, sample.cov = cov_S1, sample.nobs = 301, information = "observed")
cov_S1    <- est_S1$psi
# SM
HS.SM <- '
visual ~ textual
visual ~~ visual
textual ~~ textual
'
fit.SM <- sem(HS.SM, sample.cov = cov_S1, sample.nobs = 301, information = "observed")
# Extract all parameters
est_S1 <- lavInspect(object = fit.MM, what = "est")
cov_S1    <- est_S1$psi
# SM
HS.SM <- '
visual ~ textual
visual ~~ visual
textual ~~ textual
'
fit.SM <- sem(HS.SM, sample.cov = cov_S1, sample.nobs = 301, information = "observed")
summary(fit.SM) # Pointwise estimation is correct. SE is underestimated (as expected).
sqrt(solve(H_2) + solve(H_2) %*% I_21 %*% solve(H_1)[1:10, 1:10] %*% t(I_21) %*% solve(H_2))
p <- ncol(Data)
q <- length(lavNames(fit.MM, type = "lv"))
# First, replicate Hessian of the parameters in Step 1
obj.S1 <- function(x){
lambda <- matrix(data = 0, nrow = p, ncol = q)
lambda[1, 1] <- 1; lambda[4, 2] <- 1
lambda[2:3, 1] <- x[1:2]
lambda[5:6, 2] <- x[3:4]
theta <- matrix(data = 0, nrow = p, ncol = p)
diag(theta) <- x[5:10]
psi <- matrix(data = 0, nrow = q, ncol = q)
psi[1, 1] <- x[11]
psi[2, 2] <- x[12]
psi[2, 1] <- psi[1, 2] <- x[13]
Sigma_new <- lambda %*% psi %*% t(lambda) + theta
LL <- lavaan:::lav_mvnorm_loglik_samplestats(
sample.mean = numeric(6),
sample.nobs = 301, # Use original sample size to get the correct loglikelihood
# sample.nobs = N_gks[g, k],
sample.cov  = (cov(Data) * 300) / 301, # Factor covariance matrix from step 1
Mu          = numeric(2),
Sigma       = Sigma_new # Factor covariance matrix from step 2
)
return(-1 * LL)
}
S1par <- coef(fit.MM, type = "free")
H_1 <- numDeriv::hessian(func = obj.S1, x = S1par)
# Second, replicate the Hessian of the parameters of Step 2
obj.S2 <- function(x){
beta <- matrix(data = 0, nrow = q, ncol = q)
beta[1, 2] <- x[1]
psi <- matrix(data = 0, nrow = q, ncol = q)
psi[1, 1] <- x[2]
psi[2, 2] <- x[3]
Sigma_new <- solve(I - beta) %*% psi %*% t(solve(I - beta))
LL <- lavaan:::lav_mvnorm_loglik_samplestats(
sample.mean = numeric(2),
sample.nobs = 301,
sample.cov  = (cov_S1 * 300) / 301,
Mu          = numeric(2),
Sigma       = Sigma_new
)
return(-1 * LL)
}
I <- diag(q)
S2par <- coef(fit.SM, type = "free")
H_2 <- numDeriv::hessian(func = obj.S2, x = S2par)
# Third, replicate C. Is it possible with numDeriv?
# To replicate C, do I need the full matrix?
obj.comb <- function(x){
lambda <- matrix(data = 0, nrow = p, ncol = q)
lambda[1, 1] <- 1; lambda[4, 2] <- 1
lambda[2:3, 1] <- x[1:2]
lambda[5:6, 2] <- x[3:4]
theta <- matrix(data = 0, nrow = p, ncol = p)
diag(theta) <- x[5:10]
beta <- matrix(data = 0, nrow = q, ncol = q)
beta[1, 2] <- x[11]
psi <- matrix(data = 0, nrow = q, ncol = q)
psi[1, 1] <- x[12]
psi[2, 2] <- x[13]
Sigma_new <- lambda %*% solve(I - beta) %*% psi %*% t(solve(I - beta)) %*% t(lambda) + theta
LL <- lavaan:::lav_mvnorm_loglik_samplestats(
sample.mean = numeric(6),
sample.nobs = 301,
sample.cov  = (cov(Data) * 300) / 301,
Mu          = numeric(2),
Sigma       = Sigma_new
)
return(-1 * LL)
}
HESS <- numDeriv::hessian(func = obj.comb, x = c(S1par[1:10], S2par))
# Extract the individual parts of the matrix
I_21 <- -HESS[11:13, 1:10]
sqrt(solve(H_2) + solve(H_2) %*% I_21 %*% solve(H_1)[1:10, 1:10] %*% t(I_21) %*% solve(H_2))
# Extract the individual parts of the matrix
I_11 <- -HESS[1:10, 1:10]
I_22 <- -HESS[11:13, 11:13]
sqrt(solve(H_2) + solve(I_22) %*% I_21 %*% solve(I_11) %*% t(I_21) %*% solve(I_22))
solve(I_22) %*% I_21 %*% solve(I_11)
solve(I_22) %*% I_21 %*% solve(I_11) %*% t(I_21) %*% solve(I_22)
solve(H_2) + solve(I_22) %*% I_21 %*% solve(I_11) %*% t(I_21) %*% solve(I_22)
HESS[1:10, 1:10]
# To compare, below are the final matrices given by lavaan
# MM (This would be I_11)
info.MM <- lavInspect(object = fit.MM, what = "information")
info.MM <- info.MM*301
hess.MM <- lavInspect(object = fit.MM, what = "hessian")
hess.MM <- -hess.MM*301
info.MM
solve(info.MM)
sqrt(solve(H_2) + solve(I_22) %*% I_21 %*% solve(H_1)[1:10, 1:10] %*% t(I_21) %*% solve(I_22))
sqrt(solve(H_2) + solve(I_22) %*% I_21 %*% solve(H_1)[1:10, 1:10] %*% t(I_21) %*% solve(I_22))
round(sqrt(solve(H_2) + solve(I_22) %*% I_21 %*% solve(H_1)[1:10, 1:10] %*% t(I_21) %*% solve(I_22)), 3)
lavInspect(object = fit, what = "se")
HS.model <- '
visual  =~ x1 + x2 + x3
textual =~ x4 + x5 + x6
visual ~ textual
'
fit <- sam(HS.model, data = HolzingerSwineford1939,
mm.list = list(c("visual", "textual")),
information = "observed"
)
summary(fit)
solve(H_1)[1:10, 1:10]
round(solve(H_1)[1:10, 1:10], 3)
round(vcov(fit.MM)[1:10, 1:10], 3)
round(sqrt(vcov(fit.MM)[1:10, 1:10], 3))
round(sqrt(vcov(fit.MM)[1:10, 1:10]), 3)
round(sqrt(vcov(fit.MM)[1:10, 1:10]), 3)
sqrt(solve(H_2) + solve(I_22) %*% I_21 %*% solve(H_1)[1:10, 1:10] %*% t(I_21) %*% solve(I_22)) # Closer
fit <- sam(HS.model, data = HolzingerSwineford1939,
mm.list = list(c("visual", "textual")),
#information = "observed"
)
summary(fit)
fit <- sam(HS.model, data = HolzingerSwineford1939,
mm.list = list(c("visual", "textual")),
information = "observed"
)
summary(fit)
round(sqrt(solve(H_2) + solve(I_22) %*% I_21 %*% solve(H_1)[1:10, 1:10] %*% t(I_21) %*% solve(I_22)), 3) # Closer
fit@vcov
round(fit@vcov$vcov, 3)
round(sqrt(solve(H_2) + solve(I_22) %*% I_21 %*% solve(H_1)[1:10, 1:10] %*% t(I_21) %*% solve(I_22)), 3) # Closer
round(solve(H_2) + solve(I_22) %*% I_21 %*% solve(H_1)[1:10, 1:10] %*% t(I_21) %*% solve(I_22), 3) # Closer
browser(sam(HS.model, data = HolzingerSwineford1939,
mm.list = list(c("visual", "textual")),
information = "observed"
))
trace(sam, browser, at = 1)
fit <- sam(HS.model, data = HolzingerSwineford1939,
mm.list = list(c("visual", "textual")),
information = "observed"
)
PT$se
PT$se
PT
FIT
FIT
PTM
fit <- sam(HS.model, data = HolzingerSwineford1939,
mm.list = list(c("visual", "textual")),
information = "observed"
)
fit <- sam(HS.model, data = HolzingerSwineford1939,
mm.list = list(c("visual", "textual")),
information = "observed"
)
Sigma.11
Sigma.11
sigma.11
Sigma.11
Sigma.11
summary(lavaan(PT, slotOptions = lavoptions.joint, slotSampleStats = FIT@SampleStats,
slotData = FIT@Data))
JOINT@Options$se
VCOV.ALL
lavoptions$information
INFO
INFO*301
INFO*300
INFO*301
lavInspect(JOINT, "hessian")*301
I.22
I.22*301
N
V2
I.22.inv %*% I.21 %*% Sigma.11 %*% I.12 %*% I.22.inv
V2*301*301
solve(V2*301*301)
solve(V2)*301*301
I.22
I.22*301
solve(I.22)
solve(solve(I.22))
1/N * I.22.inv
solve(I.22)/301
solve(V2)
I.22*301
V2
solve(V2)
solve(I.22)
solve(I.22)/301
vcov(JOINT)
JOINT@vcov
(roundJOINT@vcov, 3)
round(JOINT@vcov, 3)
round(JOINT@vcov$vcov, 3)
solve(I.22*301)
round(solve(I.22*301), 3)
V2
round(V2, 3)
VCOV
sqrt(VCOV)
PT
View(partable(JOINT))
PTS
PTM
EETA
VETA
NOBS
FIT
View(partable(FIT.PA))
View(partable(FIT))
View(partable(fit.MM))
lavoptions.PA
coef(JOINT)
INFO
INFO*301
untrace(sam)
# SEM model (one-step) -------------------------------------------------------------------------------------------------
HS.model <- '
visual  =~ x1 + x2 + x3
textual =~ x4 + x5 + x6
visual ~ textual
'
fit <- sem(HS.model, data = HolzingerSwineford1939)
summary(fit, fit.measures = TRUE)
fit <- sem(HS.model, data = HolzingerSwineford1939, information = "observed")
summary(fit, fit.measures = TRUE)
source("~/GitHub/MMG-SEM/MMG-SEM.R", echo=TRUE)
model <- '
# factor loadings
F1 =~ x1 + x2 + x3 + x4 + x5
F2 =~ z1 + z2 + z3 + z4 + z5
F3 =~ m1 + m2 + m3 + m4 + m5
F4 =~ y1 + y2 + y3 + y4 + y5
# Regression parameters
F4 ~ F1 + F3
F3 ~ F1 + F2
'
Measur_model <- '
# factor loadings
F1 =~ x1 + x2 + x3 + x4 + x5
F2 =~ z1 + z2 + z3 + z4 + z5
F3 =~ m1 + m2 + m3 + m4 + m5
F4 =~ y1 + y2 + y3 + y4 + y5
'
Struc_model <- '
# Regression parameters
F4 ~ F1 + F3
F3 ~ F1 + F2
'
NonInv <- c("F1 =~ x2", "F1 =~ x3",
"F2 =~ z2", "F2 =~ z3",
"F3 =~ m2", "F3 =~ m3",
"F4 =~ y2", "F4 =~ y3")
source("~/GitHub/SE_sim/DataGeneration.R", echo=TRUE)
Data <- DataGeneration(model = model, nclus = 2, ngroups = 4, N_g = 100, reg_coeff = 0.3,
balance = "balanced", reliability = "high", NonInvSize = 0.2, NonInvItems = 2,
NonInvG = 0, NonInvType = "random", ResRange = 0.2, randomVarX = T)
library(lavaan)
Data <- DataGeneration(model = model, nclus = 2, ngroups = 4, N_g = 100, reg_coeff = 0.3,
balance = "balanced", reliability = "high", NonInvSize = 0.2, NonInvItems = 2,
NonInvG = 0, NonInvType = "random", ResRange = 0.2, randomVarX = T)
source("~/GitHub/SE_sim/E_Step.R", echo=TRUE)
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20,
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20, est_method = "global",
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
model.comb
source("~/GitHub/MMG-SEM/MMG-SEM.R", echo=TRUE)
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20, est_method = "global",
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
fake
FakeprTbl
PT.MM
PT.MM
View(PT.MM)
View(FakeprTbl)
idx.par
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20, est_method = "global",
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
idx.par
!is.na(NA)
source("~/GitHub/MMG-SEM/MMG-SEM.R", echo=TRUE)
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20, est_method = "global",
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
idx.par
length(idx.par)
length(PT.MM$est
)
PT.MM$est
source("~/GitHub/MMG-SEM/MMG-SEM.R", echo=TRUE)
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20, est_method = "global",
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
View(FakeprTbl)
View(PT.MM)
PT.MM$est[1:length(idx.par)]
source("~/GitHub/MMG-SEM/MMG-SEM.R", echo=TRUE)
source("~/GitHub/MMG-SEM/MMG-SEM.R", echo=TRUE)
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20, est_method = "global",
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
View(FakeprTbl)
View(FakeprTbl)
View(FakeprTbl)
which(FakeprTbl$lhs != this_lv & FakeprTbl$op == "~~")
this_lv
endog
var_not_this_lv
which(FakeprTbl$lhs == this_lv)
FakeprTbl[c(which(FakeprTbl$lhs == this_lv), var_not_this_lv), ]
source("~/GitHub/MMG-SEM/MMG-SEM.R", echo=TRUE)
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20, est_method = "global",
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
prTbl_idx
sort(prTbl_idx)
View(FakeprTbl[prTbl_idx, ])
source("~/GitHub/MMG-SEM/MMG-SEM.R", echo=TRUE)
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20, est_method = "local",
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
prTbl_lv
View(prTbl_lv)
View(fake_lv[[1]])
View(partable(fake_lv[[2]]))
source("~/GitHub/MMG-SEM/MMG-SEM.R", echo=TRUE)
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20, est_method = "global",
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
View(partable(fake_lv))
View(partable(fake_lv[[1]]))
View(partable(fake_lv[[2]]))
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20, est_method = "global",
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
cov_eta
reorder(cov_eta[[x]])
ngroups
1:ngroups
lapply(1:ngroups, function(x) {
reorder(cov_eta[[x]])
})
exog
source("~/GitHub/MMG-SEM/MMG-SEM.R", echo=TRUE)
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20, est_method = "global",
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
cov_eta
lambda_gs
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20, est_method = "global",
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
lambda_gs
strsplit(unlist(step1model), "\n")
unlist(strsplit(unlist(step1model), "\n"))
exog
exog[i]
c(rewritten, lines_model[grepl(exog[i], lines_model)])
endog1
source("~/GitHub/MMG-SEM/MMG-SEM.R", echo=TRUE)
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20, est_method = "global",
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
fake
lavNames(fake, "ov.y")
source("~/GitHub/MMG-SEM/MMG-SEM.R", echo=TRUE)
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20, est_method = "global",
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
lat_var
endog1
endog2
exog
source("~/GitHub/MMG-SEM/MMG-SEM.R", echo=TRUE)
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20, est_method = "global",
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
getwd()
3200 * 12
3200 * 14
44800 + 4500
44800 + 4500 + 1000
285*0.25
380/2
190-127.5
library(lavaan)
source("~/GitHub/ModelSelection_Simulation/do_sim.R", echo=TRUE)
# Set the working directory
setwd("e:/Users/perezalo/Documents/ModelSelection_Simulation/Functions")
setwd("~/GitHub/ModelSelection_Simulation")
setwd("~/GitHub/ModelSelection_Simulation/Functions")
# Source the relevant functions
source("MMG-SEM.R")
source("E_Step.R")
source("ModelSelection.R")
setwd("~/GitHub/ModelSelection_Simulation")
source("DataGeneration.R")
source("evaluation.R")
source("evaluationARI.R")
# Simulation Design
# Which factors are going to be tested? For now:
nclus   <- c(2, 4)         # Number of clusters
ngroups <- c(24, 48)       # Number of groups
coeff   <- c(0.3, 0.4)     # Initial regression parameters
N_g     <- c(50, 100, 200) # Sample size per groups
balance <- c("bal", "unb") # Cluster size
sd      <- c(0, 0.05, 0.1) # Differences within a cluster (in betas)
model <- '
# factor loadings
F1 =~ x1 + x2 + x3 + x4 + x5
F2 =~ z1 + z2 + z3 + z4 + z5
F3 =~ m1 + m2 + m3 + m4 + m5
F4 =~ y1 + y2 + y3 + y4 + y5
# Regression parameters
F4 ~ F1 + F3
F3 ~ F1 + F2
'
S1 <- '
# factor loadings
F1 =~ x1 + x2 + x3 + x4 + x5
F2 =~ z1 + z2 + z3 + z4 + z5
F3 =~ m1 + m2 + m3 + m4 + m5
F4 =~ y1 + y2 + y3 + y4 + y5
'
S2 <- '
# Regression parameters
F4 ~ F1 + F3
F3 ~ F1 + F2
'
# Get design matrix
design <- expand.grid(nclus, ngroups, coeff, N_g, balance, sd, model) # , reliability, NonInvSize, ResRange,
# NonInvItems, NonInvG, NonInvType)
colnames(design) <- c("nclus", "ngroups", "coeff", "N_g", "balance", "sd", "model")
rownames(design) <- NULL
rm(balance, coeff, N_g, nclus, ngroups, sd) #, NonInvG, NonInvItems, NonInvSize, reliability, ResRange)
# Functions for the simulation
# First, to avoid stopping due to errors, create a function with data generation and MMGSEM
# Errors come from non positive definite cov matrices. This code allows the re-sample
genDat_analysis <- function(seed, Design, RowDesign, k){
# browser()
tryCatch({
# Set seed per design condition (row) and replication (K)
set.seed(seed)
# Generate data
#SimData <- do.call(what = DataGeneration, args = Design[RowDesign, ])$SimData
SimData <- DataGeneration(model     = Design[RowDesign, "model"],
nclus     = Design[RowDesign, "nclus"],
ngroups   = Design[RowDesign, "ngroups"],
reg_coeff = Design[RowDesign, "coeff"],
N_g       = Design[RowDesign, "N_g"],
balance   = Design[RowDesign, "balance"],
sd        = Design[RowDesign, "sd"])
# Run model selection from 1 to 6 clusters
# 1. BOTH RES AND LOAD NON-INV ARE INCLUDED
results <- ModelSelection(dat = SimData$SimData, step1model = S1, step2model = S2,
group = "group", clusters = c(1, 6), nstarts = 25, seed = (RowDesign * k),
constraints = "loadings", allG = T, fit = "factors")
# If everything goes right, return results
return(results)
}, error = function(e){
return(NULL)
})
}
load("C:/Users/User/Documents/GitHub/ModelSelection_Simulation/Results/Fit/FitRow28Rep35-1.Rdata")
View(Overview)
plot(Overview$nrpar, Overview$LL); lines(Overview$nrpar, Overview$LL)
plot(Overview$nrpar_fac, Overview$LL_fac); lines(Overview$nrpar_fac, Overview$LL_fac)
load("C:/Users/User/Documents/GitHub/ModelSelection_Simulation/Results/Fit/FitRow76Rep37-1.Rdata")
plot(Overview$nrpar, Overview$LL); lines(Overview$nrpar, Overview$LL)
plot(Overview$nrpar_fac, Overview$LL_fac); lines(Overview$nrpar_fac, Overview$LL_fac)
all(is.na(Overview$Chull))
all(is.na(Overview$Chull_fac))
View(design)
6*7200
