info.MM <- lavInspect(object = fit.MM, what = "information")
info.MM <- info.MM*301
hess.MM <- lavInspect(object = fit.MM, what = "hessian")
hess.MM <- -hess.MM*301
info.MM
solve(info.MM)
sqrt(solve(H_2) + solve(I_22) %*% I_21 %*% solve(H_1)[1:10, 1:10] %*% t(I_21) %*% solve(I_22))
sqrt(solve(H_2) + solve(I_22) %*% I_21 %*% solve(H_1)[1:10, 1:10] %*% t(I_21) %*% solve(I_22))
round(sqrt(solve(H_2) + solve(I_22) %*% I_21 %*% solve(H_1)[1:10, 1:10] %*% t(I_21) %*% solve(I_22)), 3)
lavInspect(object = fit, what = "se")
HS.model <- '
visual  =~ x1 + x2 + x3
textual =~ x4 + x5 + x6
visual ~ textual
'
fit <- sam(HS.model, data = HolzingerSwineford1939,
mm.list = list(c("visual", "textual")),
information = "observed"
)
summary(fit)
solve(H_1)[1:10, 1:10]
round(solve(H_1)[1:10, 1:10], 3)
round(vcov(fit.MM)[1:10, 1:10], 3)
round(sqrt(vcov(fit.MM)[1:10, 1:10], 3))
round(sqrt(vcov(fit.MM)[1:10, 1:10]), 3)
round(sqrt(vcov(fit.MM)[1:10, 1:10]), 3)
sqrt(solve(H_2) + solve(I_22) %*% I_21 %*% solve(H_1)[1:10, 1:10] %*% t(I_21) %*% solve(I_22)) # Closer
fit <- sam(HS.model, data = HolzingerSwineford1939,
mm.list = list(c("visual", "textual")),
#information = "observed"
)
summary(fit)
fit <- sam(HS.model, data = HolzingerSwineford1939,
mm.list = list(c("visual", "textual")),
information = "observed"
)
summary(fit)
round(sqrt(solve(H_2) + solve(I_22) %*% I_21 %*% solve(H_1)[1:10, 1:10] %*% t(I_21) %*% solve(I_22)), 3) # Closer
fit@vcov
round(fit@vcov$vcov, 3)
round(sqrt(solve(H_2) + solve(I_22) %*% I_21 %*% solve(H_1)[1:10, 1:10] %*% t(I_21) %*% solve(I_22)), 3) # Closer
round(solve(H_2) + solve(I_22) %*% I_21 %*% solve(H_1)[1:10, 1:10] %*% t(I_21) %*% solve(I_22), 3) # Closer
browser(sam(HS.model, data = HolzingerSwineford1939,
mm.list = list(c("visual", "textual")),
information = "observed"
))
trace(sam, browser, at = 1)
fit <- sam(HS.model, data = HolzingerSwineford1939,
mm.list = list(c("visual", "textual")),
information = "observed"
)
PT$se
PT$se
PT
FIT
FIT
PTM
fit <- sam(HS.model, data = HolzingerSwineford1939,
mm.list = list(c("visual", "textual")),
information = "observed"
)
fit <- sam(HS.model, data = HolzingerSwineford1939,
mm.list = list(c("visual", "textual")),
information = "observed"
)
Sigma.11
Sigma.11
sigma.11
Sigma.11
Sigma.11
summary(lavaan(PT, slotOptions = lavoptions.joint, slotSampleStats = FIT@SampleStats,
slotData = FIT@Data))
JOINT@Options$se
VCOV.ALL
lavoptions$information
INFO
INFO*301
INFO*300
INFO*301
lavInspect(JOINT, "hessian")*301
I.22
I.22*301
N
V2
I.22.inv %*% I.21 %*% Sigma.11 %*% I.12 %*% I.22.inv
V2*301*301
solve(V2*301*301)
solve(V2)*301*301
I.22
I.22*301
solve(I.22)
solve(solve(I.22))
1/N * I.22.inv
solve(I.22)/301
solve(V2)
I.22*301
V2
solve(V2)
solve(I.22)
solve(I.22)/301
vcov(JOINT)
JOINT@vcov
(roundJOINT@vcov, 3)
round(JOINT@vcov, 3)
round(JOINT@vcov$vcov, 3)
solve(I.22*301)
round(solve(I.22*301), 3)
V2
round(V2, 3)
VCOV
sqrt(VCOV)
PT
View(partable(JOINT))
PTS
PTM
EETA
VETA
NOBS
FIT
View(partable(FIT.PA))
View(partable(FIT))
View(partable(fit.MM))
lavoptions.PA
coef(JOINT)
INFO
INFO*301
untrace(sam)
# SEM model (one-step) -------------------------------------------------------------------------------------------------
HS.model <- '
visual  =~ x1 + x2 + x3
textual =~ x4 + x5 + x6
visual ~ textual
'
fit <- sem(HS.model, data = HolzingerSwineford1939)
summary(fit, fit.measures = TRUE)
fit <- sem(HS.model, data = HolzingerSwineford1939, information = "observed")
summary(fit, fit.measures = TRUE)
source("~/GitHub/MMG-SEM/MMG-SEM.R", echo=TRUE)
model <- '
# factor loadings
F1 =~ x1 + x2 + x3 + x4 + x5
F2 =~ z1 + z2 + z3 + z4 + z5
F3 =~ m1 + m2 + m3 + m4 + m5
F4 =~ y1 + y2 + y3 + y4 + y5
# Regression parameters
F4 ~ F1 + F3
F3 ~ F1 + F2
'
Measur_model <- '
# factor loadings
F1 =~ x1 + x2 + x3 + x4 + x5
F2 =~ z1 + z2 + z3 + z4 + z5
F3 =~ m1 + m2 + m3 + m4 + m5
F4 =~ y1 + y2 + y3 + y4 + y5
'
Struc_model <- '
# Regression parameters
F4 ~ F1 + F3
F3 ~ F1 + F2
'
NonInv <- c("F1 =~ x2", "F1 =~ x3",
"F2 =~ z2", "F2 =~ z3",
"F3 =~ m2", "F3 =~ m3",
"F4 =~ y2", "F4 =~ y3")
source("~/GitHub/SE_sim/DataGeneration.R", echo=TRUE)
Data <- DataGeneration(model = model, nclus = 2, ngroups = 4, N_g = 100, reg_coeff = 0.3,
balance = "balanced", reliability = "high", NonInvSize = 0.2, NonInvItems = 2,
NonInvG = 0, NonInvType = "random", ResRange = 0.2, randomVarX = T)
library(lavaan)
Data <- DataGeneration(model = model, nclus = 2, ngroups = 4, N_g = 100, reg_coeff = 0.3,
balance = "balanced", reliability = "high", NonInvSize = 0.2, NonInvItems = 2,
NonInvG = 0, NonInvType = "random", ResRange = 0.2, randomVarX = T)
source("~/GitHub/SE_sim/E_Step.R", echo=TRUE)
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20,
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20, est_method = "global",
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
model.comb
source("~/GitHub/MMG-SEM/MMG-SEM.R", echo=TRUE)
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20, est_method = "global",
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
fake
FakeprTbl
PT.MM
PT.MM
View(PT.MM)
View(FakeprTbl)
idx.par
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20, est_method = "global",
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
idx.par
!is.na(NA)
source("~/GitHub/MMG-SEM/MMG-SEM.R", echo=TRUE)
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20, est_method = "global",
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
idx.par
length(idx.par)
length(PT.MM$est
)
PT.MM$est
source("~/GitHub/MMG-SEM/MMG-SEM.R", echo=TRUE)
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20, est_method = "global",
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
View(FakeprTbl)
View(PT.MM)
PT.MM$est[1:length(idx.par)]
source("~/GitHub/MMG-SEM/MMG-SEM.R", echo=TRUE)
source("~/GitHub/MMG-SEM/MMG-SEM.R", echo=TRUE)
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20, est_method = "global",
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
View(FakeprTbl)
View(FakeprTbl)
View(FakeprTbl)
which(FakeprTbl$lhs != this_lv & FakeprTbl$op == "~~")
this_lv
endog
var_not_this_lv
which(FakeprTbl$lhs == this_lv)
FakeprTbl[c(which(FakeprTbl$lhs == this_lv), var_not_this_lv), ]
source("~/GitHub/MMG-SEM/MMG-SEM.R", echo=TRUE)
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20, est_method = "global",
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
prTbl_idx
sort(prTbl_idx)
View(FakeprTbl[prTbl_idx, ])
source("~/GitHub/MMG-SEM/MMG-SEM.R", echo=TRUE)
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20, est_method = "local",
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
prTbl_lv
View(prTbl_lv)
View(fake_lv[[1]])
View(partable(fake_lv[[2]]))
source("~/GitHub/MMG-SEM/MMG-SEM.R", echo=TRUE)
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20, est_method = "global",
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
View(partable(fake_lv))
View(partable(fake_lv[[1]]))
View(partable(fake_lv[[2]]))
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20, est_method = "global",
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
cov_eta
reorder(cov_eta[[x]])
ngroups
1:ngroups
lapply(1:ngroups, function(x) {
reorder(cov_eta[[x]])
})
exog
source("~/GitHub/MMG-SEM/MMG-SEM.R", echo=TRUE)
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20, est_method = "global",
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
cov_eta
lambda_gs
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20, est_method = "global",
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
lambda_gs
strsplit(unlist(step1model), "\n")
unlist(strsplit(unlist(step1model), "\n"))
exog
exog[i]
c(rewritten, lines_model[grepl(exog[i], lines_model)])
endog1
source("~/GitHub/MMG-SEM/MMG-SEM.R", echo=TRUE)
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20, est_method = "global",
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
fake
lavNames(fake, "ov.y")
source("~/GitHub/MMG-SEM/MMG-SEM.R", echo=TRUE)
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20, est_method = "global",
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
lat_var
endog1
endog2
exog
source("~/GitHub/MMG-SEM/MMG-SEM.R", echo=TRUE)
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20, est_method = "global",
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
getwd()
3200 * 12
3200 * 14
44800 + 4500
44800 + 4500 + 1000
285*0.25
380/2
190-127.5
140*7
load("C:/Users/User/Documents/GitHub/ModelSelection_Simulation/Results/Fit/FitRow1Rep3-1.Rdata")
3147.37 - 21.40 - 25 - 213.75 - 224.75
3147.37 - 213.75
2933.62 - 154 - 150
14+13+10+6.5
3226*14
3*3*3*2*2*2*3*2
3*3*3*2*2*2*3*3
1944*50
1296*50
library(lavaan)
library(qwraps2)
library(fpp3)
library(dplyr)
library(xtable)
library(ggpubr)
library(ggplot2)
library(ggthemes)
# library(Cairo)
# CairoWin()
# Set wd
setwd("~/GitHub/ModelSelection_Simulation/Results")
# Load empty final results matrix
load("FinalResults.Rdata")
colnames(Results_final)[1:13] <- c("entropyR2", "Chull", "BIC_G", "BIC_N", "AIC", "AIC3", "ICL",
"Chull_fac", "BIC_G_fac", "BIC_N_fac", "AIC_fac", "AIC3_fac", "ICL_fac")
load("design.Rdata")
# Merge datasets
design$Condition <- as.numeric(rownames(design))
Results_final <- merge(x = design, y = Results_final, by = "Condition")
col_order <- c("Condition", "Replication", "nclus", "ngroups", "coeff", "N_g", "balance", "sd",
"entropyR2", "Chull", "BIC_G", "BIC_N", "AIC", "AIC3", "ICL",
"Chull_fac", "BIC_G_fac", "BIC_N_fac", "AIC_fac", "AIC3_fac", "ICL_fac")
Results_final <- Results_final[, col_order]
rm(col_order)
# Fill in the matrix with all results
ncond <- unique(Results_final$Condition) # How many conditions?
K <- length(unique(Results_final$Replication)) # How many replications?
for (i in ncond) {
test <- NA
test <- try(load(paste0("ResultRow", i, ".Rdata")))
if(!c(class(test) == "try-error")){
Results_final[(K*(i-1)+1):(i*K), 9:21] <- ResultsRow
}
}
# remove uncomplete entries
Results_final <- Results_final[!is.na(Results_final$BIC_G), ]
# Turn NAs from Chull into FALSE input (Chull was not able to select any model)
# apply(X = apply(X = Results_final, MARGIN = 2, FUN = is.na), MARGIN = 2, FUN = sum)
# Results_final$`Chull Scree` <- ifelse(test = is.na(Results_final$`Chull Scree`), yes = FALSE, no = Results_final$`Chull Scree`)
# Transform to factor
# changed <- Results_final %>% dplyr::select(Chull:ICL_fac) %>% as.matrix() %>% as.data.frame() %>%
#   mutate(
#     Chull     = recode(Chull, "1" = "0", "TRUE" = "0", "over" = "1", "under" = "-1"),
#     BIC_G     = recode(BIC_G, "1" = "0", "TRUE" = "0", "over" = "1", "under" = "-1"),
#     BIC_N     = recode(BIC_N, "1" = "0", "TRUE" = "0", "over" = "1", "under" = "-1"),
#     AIC       = recode(AIC, "1" = "0", "TRUE" = "0", "over" = "1", "under" = "-1"),
#     AIC3      = recode(AIC3, "1" = "0", "TRUE" = "0", "over" = "1", "under" = "-1"),
#     ICL       = recode(ICL, "1" = "0", "TRUE" = "0", "over" = "1", "under" = "-1"),
#     Chull_fac = recode(Chull_fac, "1" = "0", "TRUE" = "0", "over" = "1", "under" = "-1"),
#     BIC_G_fac = recode(BIC_G_fac, "1" = "0", "TRUE" = "0", "over" = "1", "under" = "-1"),
#     BIC_N_fac = recode(BIC_N_fac, "1" = "0", "TRUE" = "0", "over" = "1", "under" = "-1"),
#     AIC_fac   = recode(AIC_fac, "1" = "0", "TRUE" = "0", "over" = "1", "under" = "-1"),
#     AIC3_fac  = recode(AIC3_fac, "1" = "0", "TRUE" = "0", "over" = "1", "under" = "-1"),
#     ICL_fac   = recode(ICL_fac, "1" = "0", "TRUE" = "0", "over" = "1", "under" = "-1")
#   )
measures <- Results_final %>% dplyr::select(Chull:ICL_fac) %>% as.matrix() %>% as.data.frame()
measures <- lapply(X = measures, FUN = factor, levels = c("-1", "0", "1"), labels = c("Under", "Correct", "Over")) %>% as.data.frame()
Results_final[, 10:21] <- measures
Results_final[, "entropyR2"] <- as.numeric(Results_final[, "entropyR2"])
####################################################################################################
############################ TABLES - CLUSTER AND PARAMETER RECOVERY ###############################
####################################################################################################
# Check mean results per simulation factor
# Create a function for this
count_results <- function(data, by, type = "count"){
# Extract necessary columns
reduced <- data %>% dplyr::select(Chull:ICL_fac)
#Initialize objects to store
counted        <- vector(mode = "list", length = ncol(reduced))
names(counted) <- colnames(reduced)
final <- c()
# browser()
# Count per column
for(i in 1:ncol(reduced)){
if(by == "total"){
counted[[i]] <- data %>% count(get(colnames(reduced)[i]), .drop = F) %>% filter(!is.na(`get(colnames(reduced)[i])`)) # Count and remove NA
if(type == "relative"){
counted[[i]][, ncol(counted[[i]])] <- round(counted[[i]][, ncol(counted[[i]]), drop = F]/sum(counted[[i]][, ncol(counted[[i]]), drop = F]), 3)
}
# browser()
colnames(counted[[i]]) <- c("result", colnames(reduced)[i]) # change colnames
ifelse(test = i == 1, yes = final <- counted[[i]][, 1, drop = F], no = final <- final) # for the first iteration, keep the group variable and results column
final <- cbind(final, counted[[i]][, ncol(counted[[i]]), drop = F]) # Add the results for each measure
} else {
# browser()
counted[[i]] <- data %>% group_by(across(all_of(by))) %>% count(get(colnames(reduced)[i]), .drop = F) %>% filter(!is.na(`get(colnames(reduced)[i])`)) # count per measure
# browser()
if(type == "relative"){
counted[[i]][, ncol(counted[[i]])] <- round(counted[[i]][, ncol(counted[[i]])]/sum(counted[[i]][1:3, ncol(counted[[i]])]), 3)
}
colnames(counted[[i]]) <- c(by, "result", colnames(reduced)[i]) # change colnames
ifelse(test = i == 1, yes = final <- counted[[i]][, c(seq_len(length(by)), (length(by) + 1))], no = final <- final) # for the first iteration, keep the group variable and results column
final <- cbind(final, counted[[i]][, ncol(counted[[i]]), drop = F]) # Add the results for each measure
}
}
return(final)
}
# Pre-check to know if there are NAs
colSums(apply(Results_final, 2, is.na))
# Main effects
count_results(data = Results_final, by = "total", type = "relative")
count_results(data = Results_final, by = c("nclus"), type = "relative")
count_results(data = Results_final, by = c("N_g"), type = "relative")
count_results(data = Results_final, by = c("sd", "N_g"), type = "relative")
####################################################################################################
############################ TABLES - CLUSTER AND PARAMETER RECOVERY ###############################
####################################################################################################
# Check mean results per simulation factor
# Create a function for this
count_results <- function(data, by, type = "count"){
# Extract necessary columns
reduced <- data %>% dplyr::select(Chull:ICL_fac)
#Initialize objects to store
counted        <- vector(mode = "list", length = ncol(reduced))
names(counted) <- colnames(reduced)
final <- c()
# browser()
# Count per column
for(i in 1:ncol(reduced)){
if(length(by) == 1 & by == "total"){
counted[[i]] <- data %>% count(get(colnames(reduced)[i]), .drop = F) %>% filter(!is.na(`get(colnames(reduced)[i])`)) # Count and remove NA
if(type == "relative"){
counted[[i]][, ncol(counted[[i]])] <- round(counted[[i]][, ncol(counted[[i]]), drop = F]/sum(counted[[i]][, ncol(counted[[i]]), drop = F]), 3)
}
# browser()
colnames(counted[[i]]) <- c("result", colnames(reduced)[i]) # change colnames
ifelse(test = i == 1, yes = final <- counted[[i]][, 1, drop = F], no = final <- final) # for the first iteration, keep the group variable and results column
final <- cbind(final, counted[[i]][, ncol(counted[[i]]), drop = F]) # Add the results for each measure
} else {
# browser()
counted[[i]] <- data %>% group_by(across(all_of(by))) %>% count(get(colnames(reduced)[i]), .drop = F) %>% filter(!is.na(`get(colnames(reduced)[i])`)) # count per measure
# browser()
if(type == "relative"){
counted[[i]][, ncol(counted[[i]])] <- round(counted[[i]][, ncol(counted[[i]])]/sum(counted[[i]][1:3, ncol(counted[[i]])]), 3)
}
colnames(counted[[i]]) <- c(by, "result", colnames(reduced)[i]) # change colnames
ifelse(test = i == 1, yes = final <- counted[[i]][, c(seq_len(length(by)), (length(by) + 1))], no = final <- final) # for the first iteration, keep the group variable and results column
final <- cbind(final, counted[[i]][, ncol(counted[[i]]), drop = F]) # Add the results for each measure
}
}
return(final)
}
count_results(data = Results_final, by = c("sd", "N_g"), type = "relative")
####################################################################################################
############################ TABLES - CLUSTER AND PARAMETER RECOVERY ###############################
####################################################################################################
# Check mean results per simulation factor
# Create a function for this
count_results <- function(data, by, type = "count"){
# Extract necessary columns
reduced <- data %>% dplyr::select(Chull:ICL_fac)
#Initialize objects to store
counted        <- vector(mode = "list", length = ncol(reduced))
names(counted) <- colnames(reduced)
final <- c()
# browser()
# Count per column
for(i in 1:ncol(reduced)){
if(length(by) == 1 && by == "total"){
counted[[i]] <- data %>% count(get(colnames(reduced)[i]), .drop = F) %>% filter(!is.na(`get(colnames(reduced)[i])`)) # Count and remove NA
if(type == "relative"){
counted[[i]][, ncol(counted[[i]])] <- round(counted[[i]][, ncol(counted[[i]]), drop = F]/sum(counted[[i]][, ncol(counted[[i]]), drop = F]), 3)
}
# browser()
colnames(counted[[i]]) <- c("result", colnames(reduced)[i]) # change colnames
ifelse(test = i == 1, yes = final <- counted[[i]][, 1, drop = F], no = final <- final) # for the first iteration, keep the group variable and results column
final <- cbind(final, counted[[i]][, ncol(counted[[i]]), drop = F]) # Add the results for each measure
} else {
# browser()
counted[[i]] <- data %>% group_by(across(all_of(by))) %>% count(get(colnames(reduced)[i]), .drop = F) %>% filter(!is.na(`get(colnames(reduced)[i])`)) # count per measure
# browser()
if(type == "relative"){
counted[[i]][, ncol(counted[[i]])] <- round(counted[[i]][, ncol(counted[[i]])]/sum(counted[[i]][1:3, ncol(counted[[i]])]), 3)
}
colnames(counted[[i]]) <- c(by, "result", colnames(reduced)[i]) # change colnames
ifelse(test = i == 1, yes = final <- counted[[i]][, c(seq_len(length(by)), (length(by) + 1))], no = final <- final) # for the first iteration, keep the group variable and results column
final <- cbind(final, counted[[i]][, ncol(counted[[i]]), drop = F]) # Add the results for each measure
}
}
return(final)
}
count_results(data = Results_final, by = c("sd", "N_g"), type = "relative")
View(count_results(data = Results_final, by = c("sd", "N_g"), type = "relative"))
