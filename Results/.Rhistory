)
return(-1 * LL)
}
HESS <- numDeriv::hessian(func = obj.comb, x = c(S1par[1:10], S2par))
# Extract the individual parts of the matrix
I_21 <- -HESS[11:13, 1:10]
sqrt(solve(H_2) + solve(H_2) %*% I_21 %*% solve(H_1)[1:10, 1:10] %*% t(I_21) %*% solve(H_2))
# Extract the individual parts of the matrix
I_11 <- -HESS[1:10, 1:10]
I_22 <- -HESS[11:13, 11:13]
sqrt(solve(H_2) + solve(I_22) %*% I_21 %*% solve(I_11) %*% t(I_21) %*% solve(I_22))
solve(I_22) %*% I_21 %*% solve(I_11)
solve(I_22) %*% I_21 %*% solve(I_11) %*% t(I_21) %*% solve(I_22)
solve(H_2) + solve(I_22) %*% I_21 %*% solve(I_11) %*% t(I_21) %*% solve(I_22)
HESS[1:10, 1:10]
# To compare, below are the final matrices given by lavaan
# MM (This would be I_11)
info.MM <- lavInspect(object = fit.MM, what = "information")
info.MM <- info.MM*301
hess.MM <- lavInspect(object = fit.MM, what = "hessian")
hess.MM <- -hess.MM*301
info.MM
solve(info.MM)
sqrt(solve(H_2) + solve(I_22) %*% I_21 %*% solve(H_1)[1:10, 1:10] %*% t(I_21) %*% solve(I_22))
sqrt(solve(H_2) + solve(I_22) %*% I_21 %*% solve(H_1)[1:10, 1:10] %*% t(I_21) %*% solve(I_22))
round(sqrt(solve(H_2) + solve(I_22) %*% I_21 %*% solve(H_1)[1:10, 1:10] %*% t(I_21) %*% solve(I_22)), 3)
lavInspect(object = fit, what = "se")
HS.model <- '
visual  =~ x1 + x2 + x3
textual =~ x4 + x5 + x6
visual ~ textual
'
fit <- sam(HS.model, data = HolzingerSwineford1939,
mm.list = list(c("visual", "textual")),
information = "observed"
)
summary(fit)
solve(H_1)[1:10, 1:10]
round(solve(H_1)[1:10, 1:10], 3)
round(vcov(fit.MM)[1:10, 1:10], 3)
round(sqrt(vcov(fit.MM)[1:10, 1:10], 3))
round(sqrt(vcov(fit.MM)[1:10, 1:10]), 3)
round(sqrt(vcov(fit.MM)[1:10, 1:10]), 3)
sqrt(solve(H_2) + solve(I_22) %*% I_21 %*% solve(H_1)[1:10, 1:10] %*% t(I_21) %*% solve(I_22)) # Closer
fit <- sam(HS.model, data = HolzingerSwineford1939,
mm.list = list(c("visual", "textual")),
#information = "observed"
)
summary(fit)
fit <- sam(HS.model, data = HolzingerSwineford1939,
mm.list = list(c("visual", "textual")),
information = "observed"
)
summary(fit)
round(sqrt(solve(H_2) + solve(I_22) %*% I_21 %*% solve(H_1)[1:10, 1:10] %*% t(I_21) %*% solve(I_22)), 3) # Closer
fit@vcov
round(fit@vcov$vcov, 3)
round(sqrt(solve(H_2) + solve(I_22) %*% I_21 %*% solve(H_1)[1:10, 1:10] %*% t(I_21) %*% solve(I_22)), 3) # Closer
round(solve(H_2) + solve(I_22) %*% I_21 %*% solve(H_1)[1:10, 1:10] %*% t(I_21) %*% solve(I_22), 3) # Closer
browser(sam(HS.model, data = HolzingerSwineford1939,
mm.list = list(c("visual", "textual")),
information = "observed"
))
trace(sam, browser, at = 1)
fit <- sam(HS.model, data = HolzingerSwineford1939,
mm.list = list(c("visual", "textual")),
information = "observed"
)
PT$se
PT$se
PT
FIT
FIT
PTM
fit <- sam(HS.model, data = HolzingerSwineford1939,
mm.list = list(c("visual", "textual")),
information = "observed"
)
fit <- sam(HS.model, data = HolzingerSwineford1939,
mm.list = list(c("visual", "textual")),
information = "observed"
)
Sigma.11
Sigma.11
sigma.11
Sigma.11
Sigma.11
summary(lavaan(PT, slotOptions = lavoptions.joint, slotSampleStats = FIT@SampleStats,
slotData = FIT@Data))
JOINT@Options$se
VCOV.ALL
lavoptions$information
INFO
INFO*301
INFO*300
INFO*301
lavInspect(JOINT, "hessian")*301
I.22
I.22*301
N
V2
I.22.inv %*% I.21 %*% Sigma.11 %*% I.12 %*% I.22.inv
V2*301*301
solve(V2*301*301)
solve(V2)*301*301
I.22
I.22*301
solve(I.22)
solve(solve(I.22))
1/N * I.22.inv
solve(I.22)/301
solve(V2)
I.22*301
V2
solve(V2)
solve(I.22)
solve(I.22)/301
vcov(JOINT)
JOINT@vcov
(roundJOINT@vcov, 3)
round(JOINT@vcov, 3)
round(JOINT@vcov$vcov, 3)
solve(I.22*301)
round(solve(I.22*301), 3)
V2
round(V2, 3)
VCOV
sqrt(VCOV)
PT
View(partable(JOINT))
PTS
PTM
EETA
VETA
NOBS
FIT
View(partable(FIT.PA))
View(partable(FIT))
View(partable(fit.MM))
lavoptions.PA
coef(JOINT)
INFO
INFO*301
untrace(sam)
# SEM model (one-step) -------------------------------------------------------------------------------------------------
HS.model <- '
visual  =~ x1 + x2 + x3
textual =~ x4 + x5 + x6
visual ~ textual
'
fit <- sem(HS.model, data = HolzingerSwineford1939)
summary(fit, fit.measures = TRUE)
fit <- sem(HS.model, data = HolzingerSwineford1939, information = "observed")
summary(fit, fit.measures = TRUE)
source("~/GitHub/MMG-SEM/MMG-SEM.R", echo=TRUE)
model <- '
# factor loadings
F1 =~ x1 + x2 + x3 + x4 + x5
F2 =~ z1 + z2 + z3 + z4 + z5
F3 =~ m1 + m2 + m3 + m4 + m5
F4 =~ y1 + y2 + y3 + y4 + y5
# Regression parameters
F4 ~ F1 + F3
F3 ~ F1 + F2
'
Measur_model <- '
# factor loadings
F1 =~ x1 + x2 + x3 + x4 + x5
F2 =~ z1 + z2 + z3 + z4 + z5
F3 =~ m1 + m2 + m3 + m4 + m5
F4 =~ y1 + y2 + y3 + y4 + y5
'
Struc_model <- '
# Regression parameters
F4 ~ F1 + F3
F3 ~ F1 + F2
'
NonInv <- c("F1 =~ x2", "F1 =~ x3",
"F2 =~ z2", "F2 =~ z3",
"F3 =~ m2", "F3 =~ m3",
"F4 =~ y2", "F4 =~ y3")
source("~/GitHub/SE_sim/DataGeneration.R", echo=TRUE)
Data <- DataGeneration(model = model, nclus = 2, ngroups = 4, N_g = 100, reg_coeff = 0.3,
balance = "balanced", reliability = "high", NonInvSize = 0.2, NonInvItems = 2,
NonInvG = 0, NonInvType = "random", ResRange = 0.2, randomVarX = T)
library(lavaan)
Data <- DataGeneration(model = model, nclus = 2, ngroups = 4, N_g = 100, reg_coeff = 0.3,
balance = "balanced", reliability = "high", NonInvSize = 0.2, NonInvItems = 2,
NonInvG = 0, NonInvType = "random", ResRange = 0.2, randomVarX = T)
source("~/GitHub/SE_sim/E_Step.R", echo=TRUE)
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20,
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20, est_method = "global",
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
model.comb
source("~/GitHub/MMG-SEM/MMG-SEM.R", echo=TRUE)
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20, est_method = "global",
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
fake
FakeprTbl
PT.MM
PT.MM
View(PT.MM)
View(FakeprTbl)
idx.par
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20, est_method = "global",
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
idx.par
!is.na(NA)
source("~/GitHub/MMG-SEM/MMG-SEM.R", echo=TRUE)
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20, est_method = "global",
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
idx.par
length(idx.par)
length(PT.MM$est
)
PT.MM$est
source("~/GitHub/MMG-SEM/MMG-SEM.R", echo=TRUE)
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20, est_method = "global",
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
View(FakeprTbl)
View(PT.MM)
PT.MM$est[1:length(idx.par)]
source("~/GitHub/MMG-SEM/MMG-SEM.R", echo=TRUE)
source("~/GitHub/MMG-SEM/MMG-SEM.R", echo=TRUE)
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20, est_method = "global",
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
View(FakeprTbl)
View(FakeprTbl)
View(FakeprTbl)
which(FakeprTbl$lhs != this_lv & FakeprTbl$op == "~~")
this_lv
endog
var_not_this_lv
which(FakeprTbl$lhs == this_lv)
FakeprTbl[c(which(FakeprTbl$lhs == this_lv), var_not_this_lv), ]
source("~/GitHub/MMG-SEM/MMG-SEM.R", echo=TRUE)
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20, est_method = "global",
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
prTbl_idx
sort(prTbl_idx)
View(FakeprTbl[prTbl_idx, ])
source("~/GitHub/MMG-SEM/MMG-SEM.R", echo=TRUE)
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20, est_method = "local",
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
prTbl_lv
View(prTbl_lv)
View(fake_lv[[1]])
View(partable(fake_lv[[2]]))
source("~/GitHub/MMG-SEM/MMG-SEM.R", echo=TRUE)
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20, est_method = "global",
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
View(partable(fake_lv))
View(partable(fake_lv[[1]]))
View(partable(fake_lv[[2]]))
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20, est_method = "global",
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
cov_eta
reorder(cov_eta[[x]])
ngroups
1:ngroups
lapply(1:ngroups, function(x) {
reorder(cov_eta[[x]])
})
exog
source("~/GitHub/MMG-SEM/MMG-SEM.R", echo=TRUE)
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20, est_method = "global",
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
cov_eta
lambda_gs
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20, est_method = "global",
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
lambda_gs
strsplit(unlist(step1model), "\n")
unlist(strsplit(unlist(step1model), "\n"))
exog
exog[i]
c(rewritten, lines_model[grepl(exog[i], lines_model)])
endog1
source("~/GitHub/MMG-SEM/MMG-SEM.R", echo=TRUE)
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20, est_method = "global",
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
fake
lavNames(fake, "ov.y")
source("~/GitHub/MMG-SEM/MMG-SEM.R", echo=TRUE)
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20, est_method = "global",
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
lat_var
endog1
endog2
exog
source("~/GitHub/MMG-SEM/MMG-SEM.R", echo=TRUE)
res <- MMGSEM(dat = Data$SimData, step1model = Measur_model, step2model = Struc_model,
group = "group", nclus = 2, nstarts = 20, est_method = "global",
printing = F, partition = "hard", NonInv = NonInv, seed = 1,
allG = T, fit = "factors")
getwd()
3200 * 12
3200 * 14
44800 + 4500
44800 + 4500 + 1000
source("~/GitHub/ModelSelection_Simulation/do_sim.R", echo=TRUE)
library(lavaan)
# Set the working directory
setwd("e:/Users/perezalo/Documents/ModelSelection_Simulation/Functions")
setwd("~/GitHub/ModelSelection_Simulation")
setwd("~/GitHub/ModelSelection_Simulation/Functions")
# Source the relevant functions
source("MMG-SEM.R")
source("E_Step.R")
source("ModelSelection.R")
setwd("~/GitHub/ModelSelection_Simulation")
source("DataGeneration.R")
source("evaluation.R")
# Simulation Design
# Which factors are going to be tested? For now:
nclus   <- c(2, 4)         # Number of clusters
ngroups <- c(12, 48)       # Number of groups
coeff   <- c(0.3, 0.4)     # Initial regression parameters
N_g     <- c(50, 100, 200) # Sample size per groups
balance <- c("bal", "unb") # Cluster size
sd      <- c(0, 0.05, 0.1) # Differences within a cluster (in betas)
ngroups <- c(24, 48)       # Number of groups
model <- '
# factor loadings
F1 =~ x1 + x2 + x3 + x4 + x5
F2 =~ z1 + z2 + z3 + z4 + z5
F3 =~ m1 + m2 + m3 + m4 + m5
F4 =~ y1 + y2 + y3 + y4 + y5
# Regression parameters
F4 ~ F1 + F3
F3 ~ F1 + F2
'
S1 <- '
# factor loadings
F1 =~ x1 + x2 + x3 + x4 + x5
F2 =~ z1 + z2 + z3 + z4 + z5
F3 =~ m1 + m2 + m3 + m4 + m5
F4 =~ y1 + y2 + y3 + y4 + y5
'
S2 <- '
# Regression parameters
F4 ~ F1 + F3
F3 ~ F1 + F2
'
# Get design matrix
design <- expand.grid(nclus, ngroups, coeff, N_g, balance, sd, model) # , reliability, NonInvSize, ResRange,
# NonInvItems, NonInvG, NonInvType)
colnames(design) <- c("nclus", "ngroups", "coeff", "N_g", "balance", "sd", "model")
rownames(design) <- NULL
rm(balance, coeff, N_g, nclus, ngroups, sd) #, NonInvG, NonInvItems, NonInvSize, reliability, ResRange)
# Function for the simulation
do_sim <- function(Design, RowDesign, K){
# Create the original clustering matrix for comparison below
original <- create_original(balance = Design[RowDesign, "balance"],
ngroups = Design[RowDesign, "ngroups"],
nclus = Design[RowDesign, "nclus"])
# Create matrix to store results
# 12 columns for: BIC_G, BIC_N, AIC, AIC3, Chull, ICL
# There are 2 columns for each model selection measure (for factors and observed LL)
ResultsRow <- matrix(data = NA, nrow = (K), ncol = 13)
# Create second matrix for the ARI
ResultsRowARI <- matrix(data = NA, nrow = (K), ncol = 2)
for(k in 1:K){
print(paste("Replication", k, "out of", K))
# Set seed per design condition (row) and replication (K)
set.seed(RowDesign * k)
# Generate data
#SimData <- do.call(what = DataGeneration, args = Design[RowDesign, ])$SimData
SimData <- DataGeneration(model     = Design[RowDesign, "model"],
nclus     = Design[RowDesign, "nclus"],
ngroups   = Design[RowDesign, "ngroups"],
reg_coeff = Design[RowDesign, "coeff"],
N_g       = Design[RowDesign, "N_g"],
balance   = Design[RowDesign, "balance"],
sd        = Design[RowDesign, "sd"])
# reliability = Design[RowDesign, "reliability"],
# NonInvSize = Design[RowDesign, "NonInvSize"],
# NonInvItems = Design[RowDesign, "NonInvItems"],
# ResRange = Design[RowDesign, "ResRange"],
# NonInvG = Design[RowDesign, "NonInvG"],
# NonInvType = Design[RowDesign, "NonInvType"],
# randomVarX = T)
#Non-Inv Included?
# There is no non-invariance in this simulation
# NonInv <- c("F1 =~ x2", "F1 =~ x3",
#             "F2 =~ z2", "F2 =~ z3",
#             "F3 =~ m2", "F3 =~ m3",
#             "F4 =~ y2", "F4 =~ y3")
# browser()
# Run model selection from 1 to 6 clusters
# 1. BOTH RES AND LOAD NON-INV ARE INCLUDED
results <- ModelSelection(dat = SimData$SimData, step1model = S1, step2model = S2,
group = "group", clusters = c(1, 6), nstarts = 25, seed = (RowDesign * k),
constraints = "loadings", allG = T, fit = "factors")
# Save results if necessary
save(results, file = paste("Fit\Fit", "Row", RowDesign,".Rdata" , sep =""))
# Function for the simulation
do_sim <- function(Design, RowDesign, K){
# Create the original clustering matrix for comparison below
original <- create_original(balance = Design[RowDesign, "balance"],
ngroups = Design[RowDesign, "ngroups"],
nclus = Design[RowDesign, "nclus"])
# Create matrix to store results
# 12 columns for: BIC_G, BIC_N, AIC, AIC3, Chull, ICL
# There are 2 columns for each model selection measure (for factors and observed LL)
ResultsRow <- matrix(data = NA, nrow = (K), ncol = 13)
# Create second matrix for the ARI
ResultsRowARI <- matrix(data = NA, nrow = (K), ncol = 2)
for(k in 1:K){
print(paste("Replication", k, "out of", K))
# Set seed per design condition (row) and replication (K)
set.seed(RowDesign * k)
# Generate data
#SimData <- do.call(what = DataGeneration, args = Design[RowDesign, ])$SimData
SimData <- DataGeneration(model     = Design[RowDesign, "model"],
nclus     = Design[RowDesign, "nclus"],
ngroups   = Design[RowDesign, "ngroups"],
reg_coeff = Design[RowDesign, "coeff"],
N_g       = Design[RowDesign, "N_g"],
balance   = Design[RowDesign, "balance"],
sd        = Design[RowDesign, "sd"])
# reliability = Design[RowDesign, "reliability"],
# NonInvSize = Design[RowDesign, "NonInvSize"],
# NonInvItems = Design[RowDesign, "NonInvItems"],
# ResRange = Design[RowDesign, "ResRange"],
# NonInvG = Design[RowDesign, "NonInvG"],
# NonInvType = Design[RowDesign, "NonInvType"],
# randomVarX = T)
#Non-Inv Included?
# There is no non-invariance in this simulation
# NonInv <- c("F1 =~ x2", "F1 =~ x3",
#             "F2 =~ z2", "F2 =~ z3",
#             "F3 =~ m2", "F3 =~ m3",
#             "F4 =~ y2", "F4 =~ y3")
# browser()
# Run model selection from 1 to 6 clusters
# 1. BOTH RES AND LOAD NON-INV ARE INCLUDED
results <- ModelSelection(dat = SimData$SimData, step1model = S1, step2model = S2,
group = "group", clusters = c(1, 6), nstarts = 25, seed = (RowDesign * k),
constraints = "loadings", allG = T, fit = "factors")
# Save results if necessary
save(results, file = paste("Fit/Fit", "Row", RowDesign,".Rdata" , sep =""))
# ---------------------------------------------------------------
# Evaluate the results
Evaluated    <- evaluation(res = results, clus = Design[RowDesign, "nclus"])
EvaluatedARI <- evaluationARI(z_gks    = results$Models[[Design[RowDesign, "nclus"]]]$posteriors,
original = original,
nclus    = Design[RowDesign, "nclus"])
# Store the results
colnames(ResultsRow) <- colnames(Evaluated)
ResultsRow[k, ]      <- unlist(Evaluated)
colnames(ResultsRowARI) <- c("ARI", "CC")
ResultsRowARI[k, ] <- unlist(EvaluatedARI)
}
# Save the results for each row
save(ResultsRow, file = paste("Result", "Row", RowDesign,".Rdata" , sep =""))
save(ResultsRowARI, file = paste("Result", "Row", "ARI", RowDesign,".Rdata" , sep =""))
# Return the final results
return(ResultsRow)
}
setwd("~/GitHub/ModelSelection_Simulation/Results")
# Create final results matrix
# Everything is multiplied by 2 because we run the model twice (including and not including Non-Inv)
K <- 1 # Number of replications per condition
Results_final <- as.data.frame(matrix(data = NA, nrow = nrow(design)*K, ncol = 13))
Results_final$Replication <- rep(x = 1:K, times = nrow(design))
Results_final$Condition <- rep(x = 1:nrow(design), each = K)
system.time(for(i in 1:1){
cat("\n", "Condition", i, "out of", nrow(design), "\n")
Results <- do_sim(Design = design, RowDesign = i, K = K)
Results_final[(K*(i-1)+1):(i*K), 1:13] <- Results
})
setwd("~/GitHub/ModelSelection_Simulation")
source("evaluationARI.R")
setwd("~/GitHub/ModelSelection_Simulation/Results")
system.time(for(i in 1:1){
cat("\n", "Condition", i, "out of", nrow(design), "\n")
Results <- do_sim(Design = design, RowDesign = i, K = K)
Results_final[(K*(i-1)+1):(i*K), 1:13] <- Results
})
??instvy
